{"version":3,"sources":["reportWebVitals.ts","images/kitty.jpg","game-state-start.jsx","grid.jsx","logic.js","game-state-running.jsx","game.jsx","index.tsx"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","GameStateStart","onStart","className","type","onClick","Grid","imgSrc","$img","onLoad","pieceSizeRatio","useState","imgWidth","width","imgHeight","height","state","setState","tableRef","useRef","useEffect","current","onResize","window","addEventListener","removeEventListener","desiredPieceSize","Math","min","gridWidth","round","gridHeight","pieceWidth","pieceHeight","runningID","cellStyle","grid","y","row","x","pieceStyle","left","top","push","data-id","style","alt","src","ref","$","jQuery","GameLogic","stage","img","this","$grid","$stage","callbacks","prototype","events","FINISHED","start","addClass","that","find","each","$piecePositioner","$piece","setTimeout","scramblePiece","draggable","stack","snap","snapMode","snapTolerance","max","containment","removeClass","stop","droppable","tolerance","drop","event","ui","$this","offset","$currentPiece","data","isFinished","callback","out","resize","i","piece","allCorrectlyPlaced","pieceRect","getBoundingClientRect","stageRect","imgRect","rnd","random","right","bottom","toggleHelp","toggle","setCallback","GameStateRunning","logic","setLogic","showGrid","setShowGrid","imgRef","stageRef","onload","setupGameLogic","useCallback","alert","htmlFor","id","disabled","onChange","e","target","checked","Game","setCurrentGameState","currentGameState","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9982f4d9.chunk.js","sourcesContent":["import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","export default __webpack_public_path__ + \"static/media/kitty.9149cd00.jpg\";","import React from 'react';\n\n\n// The first game state. It just shows an introduction and a button that the player can click\n// when they're ready.\nexport default function GameStateStart({onStart}) {\n\n  return (\n    <div>\n      <header className=\"page-header\">\n        <h1>So Puzzled!! <br /> <small>A little puzzle game for practice, written in React and jQueryUI</small></h1>\n      </header>\n\n      <section className=\"jumbotron text-center\">\n\n        <h2>How to play:</h2>\n\n        <ol className=\"text-left inline-block\">\n          <li>Click the <strong className=\"\">Start</strong> button</li>\n          <li>Memorize the image</li>\n          <li>Piece the image back together</li>\n          <li>.. profit?</li>\n        </ol>\n\n        <p>\n          <button type=\"button\" className=\"btn btn-success btn-lg\" onClick={onStart}>Start Puzzling</button>\n        </p>\n\n      </section>\n    </div>\n  );\n\n}\n","import React, { useEffect, useRef, useState } from 'react'\n\n\n\n/** The grid where the puzzle pieces are placed.\n *  The application flow is set up so that this grid is created & rendered\n *  AFTER the base-image is loaded and displayed. The image's is described in\n *  the css to maintain EXACTLY the shape we need to set up the game around it,\n *  therefore you will find a LOT of references to the image's dimensions here!\n */\nexport default function Grid({imgSrc, $img, onLoad, pieceSizeRatio}) {\n\n  const [state, setState] = useState({\n    imgWidth: $img.width,\n    imgHeight: $img.height,\n  })\n\n  const tableRef = useRef()\n\n  useEffect(() => {\n    // TODO: make this callback somehow more elegant\n    onLoad(tableRef.current);\n  }, [onLoad])\n\n  useEffect(() => {\n    // After the component is rendered, we keep track of the window's resize events.\n    // If one is fired, we rely on the image being resized correctly (via css) so we\n    // can use it to update the state.\n    const onResize = () => setState(state => ({\n      ...state,\n      imgWidth: $img.width,\n      imgHeight: $img.height\n    }))\n\n    window.addEventListener('resize', onResize)\n\n    return () => window.removeEventListener('resize', onResize)\n\n  }, [$img.width, $img.height])\n\n  const {imgWidth,imgHeight} = state\n\n  // the desired piece-size is set to be roughly 1 / pieceSizeRatio of the shorter side of the image.\n  const desiredPieceSize = Math.min(imgWidth, imgHeight) / pieceSizeRatio;\n\n  // Here we calculate how many rows and columns we can make from those sizes ..\n  const gridWidth = Math.round(imgWidth / desiredPieceSize);\n  const gridHeight = Math.round(imgHeight / desiredPieceSize);\n\n  // .. and set the ACTUAL pieceSize so the pieces will fit into such a grid\n  const pieceWidth = imgWidth / gridWidth;\n  const pieceHeight = imgHeight / gridHeight;\n\n  // an id to give to the grid-cells and their pieces to make it easier to check if a piece\n  // has been placed correctly\n  let runningID = 0;\n\n  // the cells should be the same dimensiona as the pieces\n  const cellStyle = {\n    width: pieceWidth,\n    height: pieceHeight\n  };\n\n  // Here we create the grid\n  const grid = [];\n  for (let y = 0; y < gridHeight; y += 1)\n  {\n    const row = [];\n\n    for (let x = 0; x < gridWidth; x += 1)\n    {\n\n      // Each piece contains an <img> element that is negatively offset by the same distance as\n      // the piece is from the image's origin.\n      const pieceStyle = {\n        width: imgWidth,\n        height: imgHeight,\n        left: x * pieceWidth * -1,\n        top: y * pieceHeight * -1\n      };\n\n      runningID += 1;\n\n      // The 'animated' class gives the piece a css-transition when it is scrambled.\n      // This allows us to quickly turn the transition off when we want to move the\n      // piece around manually.\n      row.push((\n        <td key={x} className=\"piece-positioner\" data-id={runningID} style={cellStyle}>\n          <div className=\"piece-wrapper animated\" data-id={runningID} >\n            <img alt={`piece #${runningID}`} src={imgSrc} className=\"piece\" style={pieceStyle} />\n          </div>\n        </td>\n      ));\n\n    }\n\n    grid.push((\n      <tr key={y}>\n        {row}\n      </tr>\n    ))\n  }\n\n  return (\n    <table ref={tableRef} className=\"game-grid\">\n      <tbody>\n        {grid}\n      </tbody>\n    </table>\n  );\n\n}\n","const $ = window.jQuery\n\n// This class encapsulates the game's logic and the interactions with jQueryUI.\n// TODO: split those things up.\nfunction GameLogic(grid, stage, img) {\n\n  this.$grid = $(grid);\n  this.$stage = $(stage);\n  this.$img = $(img);\n\n  // this callbacks object, the 'GameLogic.prototype.events', and the 'setCallback' method\n  // create a super simple pub/sub functionality\n  this.callbacks = {};\n\n}\n\n\n// an enum\nGameLogic.prototype.events = {\n  FINISHED: 0\n};\n\n\n// When the start method is called ..\nGameLogic.prototype.start = function () {\n\n  // .. we hide the base-image ..\n  this.$img.addClass('transparent');\n\n  var that = this;\n\n  // .. then iterate over the grid's cells and for each cell ..\n  this.$grid.find('.piece-positioner').each(function () {\n    var $piecePositioner = $(this);\n    // .. we find the contained piece.\n    var $piece = $piecePositioner.find('.piece-wrapper');\n\n    // Each piece gets scrambled it (after a short random delay, so the pieces don't all do the same thing)\n    setTimeout(function () {\n      that.scramblePiece($piece);\n      // (the class 'scramble' tells us that the piece should be scrambled again when the window resizes)\n      $piece.addClass('scramble');\n    }, 1000);\n\n    // We make the piece draggable\n    $piece.draggable({\n      stack: '.piece-wrapper',    // this makes the currently dragged piece pop to the front of the z-buffer\n      snap: '.piece-positioner',  // this makes it snap to the grid-cells\n      snapMode: 'inner',\n      snapTolerance: Math.max($piece.width(), $piece.height()) / 4, // kinda random snap-tolerance, found by trial-and-error\n      containment: that.$stage,   // the pieces should be constrained to the stage div\n      start: function () {\n        // we don't want the piece to have a transition while we drag it!\n        $piece.removeClass('animated');\n      },\n      stop: function () {\n        $piece.addClass('animated');\n      }\n    });\n\n    // The grid cell becomes a droppable target\n    $piecePositioner.droppable({\n      tolerance: \"intersect\",\n        drop: function( event, ui ) {\n          // when a piece is dropped in a cell ..\n          var $this = $(this);\n          var $piece = $(ui.draggable);\n\n          // .. we first give it the same offset as the cell, to make sure it sits flush inside\n          $piece.offset($this.offset());\n\n          // then we check if there's already a piece in the cell (dropped pieces get stored in the\n          // cell's data-attribute) and it's not the same one as the dropped one.\n          var $currentPiece = $this.data('currentPiece');\n          if ($currentPiece && $currentPiece.data('id') !== $piece.data('id'))\n          {\n            // if that's the case, scramble the old one\n            that.scramblePiece($currentPiece);\n          }\n\n          // either way, we set the dropped one as the currentPiece ..\n          $this.data('currentPiece', $piece);\n          // .. and remove the 'scramble' class, so the piece doesn't get moved around if the window resizes\n          $piece.removeClass('scramble');\n\n          // if the piece has the same id as the cell, meaning it' in the right position, ..\n          if ($piece.data('id') === $this.data('id'))\n          {\n            $this\n              .addClass('done')        // .. we add the class 'done' to it, which removes the cell's border ..\n              .droppable('destroy');   // .. and remove the drag/drop functionality\n\n            $piece\n              .draggable('destroy');\n          }\n\n          // last we check if the puzzle is solved\n          if (that.isFinished())\n          {\n            // if that's the case and there's a callback subscribed for this ..\n            var callback = that.callbacks[that.events.FINISHED];\n            if (callback)\n            {\n              // we call it\n              callback(that);\n            }\n\n          }\n\n        },\n        out: function (event, ui) {\n          // when we move a piece out of a cell ..\n          var $piece = $(ui.draggable);\n          var $currentPiece = $(this).data('currentPiece');\n\n          // .. we check whether it just happened to be sitting there, or whether it was dropped here on purpose.\n          if ($currentPiece && $currentPiece.data('id') === $piece.data('id'))\n          {\n            // in the later case, we unset the droppable's current piece ..\n            $(this).data('currentPiece', null);\n            // .. and re-add the 'scramble' class\n            $piece.addClass('scramble');\n          }\n        }\n    });\n\n  });\n\n  // lastly we listen to the window resizing\n  $(window).resize(function () {\n\n    // if the window resizes, we go through all the grid cells\n    that.$grid.find('.piece-positioner').each(function () {\n      var $piecePositioner = $(this);\n\n      // if they have a current piece attached ..\n      var $piece = $piecePositioner.data('current-piece');\n      if ($piece)\n      {\n        // .. we give it the same new offset as the cell\n        $piece\n          .removeClass('animated')\n          .offset($piecePositioner.offset())\n          .addClass('animated');\n      }\n\n      // alse we check on the cell's actual piece (as opposed to iterating over the\n      // pieces in a separate loop) and if it has the scramble class, we scramble it.\n      $piecePositioner.find('.piece-wrapper.scramble').each(function (i, piece) {\n        that.scramblePiece($(piece));\n      });\n\n    });\n\n  });\n\n};\n\n\n// Check if the puzzle is solved\nGameLogic.prototype.isFinished = function () {\n  var allCorrectlyPlaced;\n\n  // iterate over each cell ..\n  $('.piece-positioner').each(function () {\n\n    // and check whether the attached piece has the same data-attribute id as the cell\n    allCorrectlyPlaced = $(this).data('currentPiece') && $(this).data('currentPiece').data('id') === $(this).data('id');\n\n    // if that's not the case, we return the overall result, which is now false, which gives us a nice early-out\n    return !!allCorrectlyPlaced;\n\n  });\n\n  return !!allCorrectlyPlaced;\n};\n\n\n// scramblePiece moves a piece to a random position somewhere in the viewport (represented by the stage)\nGameLogic.prototype.scramblePiece = function ($piece) {\n\n  var pieceRect = $piece[0].getBoundingClientRect();\n  var stageRect = this.$stage[0].getBoundingClientRect();\n  var imgRect = this.$img[0].getBoundingClientRect();\n\n  var rnd = Math.random;\n  var top, left;\n\n  // if the stage is wider that the base-image plus 1 1/2 piece-widths on either side, we put the piece on the\n  // sides.\n  if (stageRect.width > (imgRect.width + pieceRect.width * 3))\n  {\n    // top position is somewhere along the height of the stage\n    top = rnd() * (stageRect.height - pieceRect.height);\n\n    // left position is either ..\n    if (rnd() > 0.5)\n    {\n      // .. between the left window boundary and the base-image's left edge, or ..\n      left = imgRect.right + rnd() * (stageRect.right - imgRect.right - pieceRect.width);\n    }\n    else\n    {\n      // .. between the base-image's right edge and the right window boundary\n      left = stageRect.left + rnd() * (imgRect.left - stageRect.left - pieceRect.width);\n    }\n  }\n  else\n  {\n    // if there's no space on the sides, we put the piece somewhere below the base-image (the\n    // base-image has a max-height of 60vh to ensure that there's always enough space below it)\n    left = stageRect.left + rnd() * (stageRect.right - pieceRect.width);\n    top = imgRect.bottom + rnd() * (stageRect.bottom - imgRect.bottom - pieceRect.height);\n  }\n\n  $piece.offset({\n    top: top,\n    left: left\n  });\n\n};\n\n\n// Toggle the help on or off.\nGameLogic.prototype.toggleHelp = function (toggle) {\n\n  if (toggle)\n  {\n    // help means the base-image is semi-transparent, so we can se where the pieces should go\n    this.$img.addClass('semi-transparent');\n  }\n  else\n  {\n    this.$img.removeClass('semi-transparent');\n  }\n\n};\n\n\n// attache a callback. Currently only used for the FINISH event\nGameLogic.prototype.setCallback = function (event, callback) {\n  this.callbacks[event] = callback;\n};\n\n\nexport default GameLogic;\n","import React, {useCallback, useEffect, useRef, useState} from'react';\nimport GameGrid from'./grid.jsx';\nimport GameLogic from'./logic.js';\n\n\n\n// The game state where the actual fun happens.\nexport default function GameStateRunning({img}) {\n\n  const [logic, setLogic] = useState(null)\n  const [showGrid, setShowGrid] = useState(false)\n\n  const imgRef = useRef()\n  const stageRef = useRef()\n\n  useEffect(() => {\n    // the component did mount, but the image might not have loaded completely yet, therefore\n    // we attach this onLoad function.\n    imgRef.current.onload = (function () {\n      // The image has loaded (yay!). Now we set a short timeout of 2s so the player\n      // has some time to memorize the image ..\n      setTimeout (function () {\n        // .. then we tell the component to show the grid (this will trigger a re-render)\n        setShowGrid(true);\n      }, 2000);\n    });\n  }, [])\n\n\n\n  // Sets up the game logic (duh). This is called after the game-grid component has fully rendered.\n  const setupGameLogic = useCallback(grid => {\n\n    // Create a new instance of GameLogic, passing it the components it\n    // requires (via their refs), ..\n    var logic = new GameLogic(grid, stageRef.current, imgRef.current);\n\n    // .. make it start, ..\n    logic.start();\n\n    // .. listen to when it finishes, ..\n    logic.setCallback(logic.events.FINISHED, function () {\n      window.alert('You did it!! (reload the window to play again)');\n    });\n\n    // .. and finally put it on the state (this causes a re-render with the need-help-button activated)\n    setLogic(logic);\n\n  }, [])\n\n\n  // renders the \"menu\", ie the title-bar with the toggle-button to show the image\n  function renderMenu() {\n\n    return (\n      <nav className=\"navbar navbar-default\">\n        <div className=\"container-fluid\">\n          <div className=\"navbar-brand\">\n            So Puzzled!\n          </div>\n          <label className=\"navbar-text pull-right\" htmlFor=\"help\">\n            <input\n              id=\"help\"\n              type=\"checkbox\"\n              // While the game logic is not initialised yet, this button stays disabled.\n              disabled={!logic}\n              // Callback function that calls the game logic's toggleHelp method.\n              // Kinda wish I had written this in ES6 now and could use arrow functions.\n              onChange={e => logic.toggleHelp(!!e.target.checked)}\n            />\n            &nbsp;\n            Need Help?\n\n          </label>\n        </div>\n      </nav>\n    );\n\n  }\n\n\n  // This renders the image below the grid\n  function renderBaseImg() {\n    return (\n      <img\n        alt=\"Kitty\"\n        src={img}\n        className=\"base-img\"\n        ref={imgRef}\n      />\n    );\n  }\n\n\n  // This renders the GameGrid component\n  function renderGrid() {\n    if (showGrid) {\n      // The GameGrid component requires\n      // - the image that we want to puzzle,\n      // - the desired size for the puzzle-pieces, and\n      // - this.setupGameLogic, as a callback method for when the grid is ready\n      //\n      // TODO: pass this callback somehow more elegantly or use Flux.\n      // TODO: expose the pieceSizeRatio to a menu or something so players can use it to set the difficulty level\n      return (\n        <GameGrid\n          imgSrc={img}\n          $img={imgRef.current}\n          pieceSizeRatio={4}\n          onLoad={setupGameLogic}\n        />\n      );\n    } else {\n      return null;\n    }\n  }\n\n\n  // renderStage renders a fixed-positioned <div> that spans the whole screen and serves as\n  // a boundary for the scrambled puzzle-pieces and a reference to the visible area.\n  // Not strictly necessary but on pages with a lot of moving parts I like to have an abstract\n  // element like this to keep track of the viewport for me.\n  function renderStage() {\n    return (\n      <div ref={stageRef} className=\"container stage\" />\n    );\n  }\n\n  // The main render function. The more interesting bits are rendered in smaller functions\n  return (\n    <div>\n\n      {renderMenu()}\n      <div className=\"game-wrapper\">\n        {renderStage()}\n        <div className=\"grid-wrapper\">\n          {renderBaseImg()}\n          {renderGrid()}\n        </div>\n      </div>\n\n    </div>\n  );\n\n};\n","import React, {useState} from 'react'\nimport GameStateStart from './game-state-start.jsx'\nimport GameStateRunning from './game-state-running.jsx'\n\n\n\n// The Game-object. In a larger application should probably be split up more, with\n// React JUST providing the presentation layer and the logic factored into it's own\n// object, but for a small project like this it's just too convenient.\nexport default function Game({img}) {\n\n  // the first state that we see in the game, the start-state, with an explanation\n  // how to play, etc.\n  const [currentGameState, setCurrentGameState] = useState((\n    <GameStateStart onStart={start} />\n  ))\n\n  // changes to the game state that actually runs the game.\n  function start() {\n    setCurrentGameState((\n      <GameStateRunning img={img} />\n    ))\n  }\n\n  // Render the game\n  return currentGameState;\n\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\n\nimport img from './images/kitty.jpg'\n\n\nimport Game from './game';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Game img={img} />\n  </React.StrictMode>,\n  document.getElementById('app')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}