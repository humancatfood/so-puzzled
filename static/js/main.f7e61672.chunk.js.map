{"version":3,"sources":["images/kitty.jpg","StartScreen.tsx","logic.ts","Menu.tsx","Piece.tsx","Grid.tsx","Game.tsx","utils.ts","App.tsx","index.tsx"],"names":["GameStateStart","onStart","className","type","onClick","$","window","jQuery","GameLogic","grid","stage","img","callbacks","$grid","$stage","$img","this","that","find","each","index","item","$piecePositioner","$piece","setTimeout","scramblePiece","addClass","draggable","stack","snap","snapMode","snapTolerance","Math","max","width","height","containment","start","removeClass","stop","droppable","tolerance","drop","event","ui","$this","offset","$currentPiece","data","isFinished","forEach","cb","out","resize","piece","allCorrectlyPlaced","top","left","pieceRect","getBoundingClientRect","stageRect","imgRect","rnd","random","right","bottom","callback","push","Menu","toggleHelp","htmlFor","id","disabled","onChange","e","target","checked","Piece","pieceWidth","pieceHeight","canvasRef","useRef","useEffect","ctx","current","getContext","drawImage","data-id","ref","Grid","imgSrc","onLoad","pieceSizeRatio","tableRef","desiredPieceSize","min","gridWidth","round","gridHeight","useMemo","Image","src","Array","fill","map","_","y","x","style","ConditionalGrid","props","Game","useState","showHelp","setShowHelp","isStarted","setStarted","showGrid","setShowGrid","imgRef","stageRef","element","size","setSize","observer","ResizeObserver","entries","contentRect","observe","unobserve","useElementSize","imgWidth","imgHeight","setupGameLogic","useCallback","logic","onFinished","alert","alt","App","console","log","version","process","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f7e61672.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/kitty.9149cd00.jpg\";","type GameStateStartProps = {\n  onStart: () => void\n}\n\n\n// The first game state. It just shows an introduction and a button that the player can click\n// when they're ready.\nexport default function GameStateStart({ onStart }: GameStateStartProps) {\n  return (\n    <>\n      <header className=\"page-header\">\n        <h1>So Puzzled!! <br /> <small>A little puzzle game for practice, written in React and jQueryUI</small></h1>\n      </header>\n\n      <main className=\"jumbotron text-center\">\n\n        <h2>How to play:</h2>\n\n        <ol className=\"text-left inline-block\">\n          <li>Click the <strong className=\"\">Start</strong> button</li>\n          <li>Memorize the image</li>\n          <li>Piece the image back together</li>\n          <li>.. profit?</li>\n        </ol>\n\n        <p>\n          <button type=\"button\" className=\"btn btn-success btn-lg\" onClick={onStart}>Start Puzzling</button>\n        </p>\n\n      </main>\n    </>\n  )\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\ndeclare let window : any\n\nconst $ = window.jQuery\n\n\n\n// This class encapsulates the game's logic and the interactions with jQueryUI.\n// TODO: split those things up.\nclass GameLogic {\n\n  callbacks: Array<() => void> = []\n\n  $grid: any\n  $stage: any\n  $img: any\n\n  constructor(grid: HTMLElement, stage: HTMLElement, img: HTMLImageElement) {\n    this.$grid = $(grid)\n    this.$stage = $(stage)\n    this.$img = $(img)\n  }\n\n  start () {\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const that = this\n\n    // .. then iterate over the grid's cells and for each cell ..\n    this.$grid.find('.piece-positioner').each((index:number, item: HTMLElement) => {\n      const $piecePositioner = $(item)\n      // .. we find the contained piece.\n      const $piece = $piecePositioner.find('.piece-wrapper')\n\n      // Each piece gets scrambled it (after a short random delay, so the pieces don't all do the same thing)\n      setTimeout(() => {\n        that.scramblePiece($piece)\n        // (the class 'scramble' tells us that the piece should be scrambled again when the window resizes)\n        $piece.addClass('scramble')\n      }, 1000)\n\n      // We make the piece draggable\n      $piece.draggable({\n        stack: '.piece-wrapper',    // this makes the currently dragged piece pop to the front of the z-buffer\n        snap: '.piece-positioner',  // this makes it snap to the grid-cells\n        snapMode: 'inner',\n        snapTolerance: Math.max($piece.width(), $piece.height()) / 4, // kinda random snap-tolerance, found by trial-and-error\n        containment: that.$stage,   // the pieces should be constrained to the stage div\n        start: function () {\n          // we don't want the piece to have a transition while we drag it!\n          $piece.removeClass('animated')\n        },\n        stop: function () {\n          $piece.addClass('animated')\n        },\n      })\n\n      // The grid cell becomes a droppable target\n      $piecePositioner.droppable({\n        tolerance: 'intersect',\n        drop: function(event: any, ui: any) {\n          // when a piece is dropped in a cell ..\n          const $this = $(this)\n          const $piece = $(ui.draggable)\n\n          // .. we first give it the same offset as the cell, to make sure it sits flush inside\n          $piece.offset($this.offset())\n\n          // then we check if there's already a piece in the cell (dropped pieces get stored in the\n          // cell's data-attribute) and it's not the same one as the dropped one.\n          const $currentPiece = $this.data('currentPiece')\n          if ($currentPiece && $currentPiece.data('id') !== $piece.data('id'))\n          {\n            // if that's the case, scramble the old one\n            that.scramblePiece($currentPiece)\n          }\n\n          // either way, we set the dropped one as the currentPiece ..\n          $this.data('currentPiece', $piece)\n          // .. and remove the 'scramble' class, so the piece doesn't get moved around if the window resizes\n          $piece.removeClass('scramble')\n\n          // if the piece has the same id as the cell, meaning it' in the right position, ..\n          if ($piece.data('id') === $this.data('id'))\n          {\n            $this\n              .addClass('done')        // .. we add the class 'done' to it, which removes the cell's border ..\n              .droppable('destroy')   // .. and remove the drag/drop functionality\n\n            $piece\n              .draggable('destroy')\n          }\n\n          // last we check if the puzzle is solved\n          if (that.isFinished())\n          {\n            // if that's the case and there's a callback subscribed for this ..\n            that.callbacks.forEach(cb => cb())\n          }\n\n        },\n        out: function (event: any, ui: any) {\n          // when we move a piece out of a cell ..\n          const $piece = $(ui.draggable)\n          const $currentPiece = $(this).data('currentPiece')\n\n          // .. we check whether it just happened to be sitting there, or whether it was dropped here on purpose.\n          if ($currentPiece && $currentPiece.data('id') === $piece.data('id'))\n          {\n            // in the later case, we unset the droppable's current piece ..\n            $(this).data('currentPiece', null)\n            // .. and re-add the 'scramble' class\n            $piece.addClass('scramble')\n          }\n        },\n      })\n\n    })\n\n    // lastly we listen to the window resizing\n    $(window).resize(function () {\n\n      // if the window resizes, we go through all the grid cells\n      that.$grid.find('.piece-positioner').each((index: number, item: HTMLElement) => {\n        const $piecePositioner = $(item)\n\n        // if they have a current piece attached ..\n        const $piece = $piecePositioner.data('current-piece')\n        if ($piece)\n        {\n          // .. we give it the same new offset as the cell\n          $piece\n            .removeClass('animated')\n            .offset($piecePositioner.offset())\n            .addClass('animated')\n        }\n\n        // alse we check on the cell's actual piece (as opposed to iterating over the\n        // pieces in a separate loop) and if it has the scramble class, we scramble it.\n        $piecePositioner.find('.piece-wrapper.scramble').each((index: number, piece: HTMLElement) => {\n          that.scramblePiece($(piece))\n        })\n\n      })\n\n    })\n  }\n\n  isFinished(): boolean {\n    let allCorrectlyPlaced\n\n    // iterate over each cell ..\n    $('.piece-positioner').each((index: number, piece: HTMLElement) => {\n\n      // and check whether the attached piece has the same data-attribute id as the cell\n      allCorrectlyPlaced = $(piece).data('currentPiece') && $(piece).data('currentPiece').data('id') === $(piece).data('id')\n\n      // if that's not the case, we return the overall result, which is now false, which gives us a nice early-out\n      return !!allCorrectlyPlaced\n\n    })\n\n    return !!allCorrectlyPlaced\n  }\n\n  // scramblePiece moves a piece to a random position somewhere in the viewport (represented by the stage)\n  scramblePiece($piece: any): void {\n\n    const pieceRect = $piece[0].getBoundingClientRect()\n    const stageRect = this.$stage[0].getBoundingClientRect()\n    const imgRect = this.$img[0].getBoundingClientRect()\n\n    const rnd = Math.random\n    let top, left\n\n    // if the stage is wider that the base-image plus 1 1/2 piece-widths on either side, we put the piece on the\n    // sides.\n    if (stageRect.width > (imgRect.width + pieceRect.width * 3))\n    {\n    // top position is somewhere along the height of the stage\n      top = rnd() * (stageRect.height - pieceRect.height)\n\n      // left position is either ..\n      if (rnd() > 0.5)\n      {\n      // .. between the left window boundary and the base-image's left edge, or ..\n        left = imgRect.right + rnd() * (stageRect.right - imgRect.right - pieceRect.width)\n      }\n      else\n      {\n      // .. between the base-image's right edge and the right window boundary\n        left = stageRect.left + rnd() * (imgRect.left - stageRect.left - pieceRect.width)\n      }\n    }\n    else\n    {\n    // if there's no space on the sides, we put the piece somewhere below the base-image (the\n    // base-image has a max-height of 60vh to ensure that there's always enough space below it)\n      left = stageRect.left + rnd() * (stageRect.right - pieceRect.width)\n      top = imgRect.bottom + rnd() * (stageRect.bottom - imgRect.bottom - pieceRect.height)\n    }\n\n    $piece.offset({\n      top: top,\n      left: left,\n    })\n\n  }\n\n  // attache a callback. Currently only used for the FINISH event\n  onFinished(callback: () => void): void {\n    this.callbacks.push(callback)\n  }\n}\n\n\nexport default GameLogic\n","type MenuProps = {\n  toggleHelp?: (on: boolean) => void\n}\n\nexport default function Menu({ toggleHelp }: MenuProps) {\n  return (\n    <header className=\"navbar navbar-default\">\n      <div className=\"container-fluid\">\n        <div className=\"navbar-brand\">\n          So Puzzled!\n        </div>\n        <label className=\"navbar-text pull-right\" htmlFor=\"help\">\n          <input\n            id=\"help\"\n            type=\"checkbox\"\n            // While the game logic is not initialised yet, this button stays disabled.\n            disabled={!toggleHelp}\n            // Callback function that calls the game logic's toggleHelp method.\n            // Kinda wish I had written this in ES6 now and could use arrow functions.\n            onChange={e => toggleHelp && toggleHelp(!!e.target.checked)}\n          />\n          &nbsp;\n          Need Help?\n        </label>\n      </div>\n    </header>\n  )\n}\n","import { useEffect, useRef } from 'react'\n\n\ntype PieceProps = {\n  id: string\n  width: number\n  height: number\n  pieceWidth: number\n  pieceHeight: number\n  left: number\n  top: number\n  img: HTMLImageElement\n}\n\n\nexport default function Piece({ id, width, height, left, top, img, pieceWidth, pieceHeight }: PieceProps) {\n\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n\n  useEffect(() => {\n    const ctx = canvasRef.current?.getContext('2d')\n    ctx?.drawImage(img, left, top, width, height)\n  }, [width, height, left, top, img])\n\n  return (\n    <canvas\n      className=\"piece-wrapper animated\"\n      data-id={id}\n      ref={canvasRef}\n      width={pieceWidth}\n      height={pieceHeight}\n    />\n  )\n\n}\n","import { useEffect, useMemo, useRef } from 'react'\n\nimport Piece from './Piece'\n\ntype GridProps = {\n  imgSrc: string\n  width: number,\n  height: number,\n  onLoad: (grid: HTMLTableElement|null) => void\n  pieceSizeRatio: number\n}\n\n\n/** The grid where the puzzle pieces are placed.\n *  The application flow is set up so that this grid is created & rendered\n *  AFTER the base-image is loaded and displayed. The image's is described in\n *  the css to maintain EXACTLY the shape we need to set up the game around it,\n *  therefore you will find a LOT of references to the image's dimensions here!\n */\nfunction Grid({ imgSrc, width, height, onLoad, pieceSizeRatio }: GridProps) {\n\n  const tableRef = useRef<HTMLTableElement>(null)\n\n  useEffect(() => {\n    // TODO: make this callback somehow more elegant\n    if (tableRef.current && width && height) {\n      onLoad(tableRef.current)\n    }\n  }, [onLoad, width, height])\n\n  const desiredPieceSize = Math.min(width, height) / pieceSizeRatio\n\n  // Here we calculate how many rows and columns we can make from those sizes ..\n  const gridWidth = Math.round(width / desiredPieceSize)\n  const gridHeight = Math.round(height / desiredPieceSize)\n\n  // .. and set the ACTUAL pieceSize so the pieces will fit into such a grid\n  const pieceWidth = width / gridWidth\n  const pieceHeight = height / gridHeight\n\n  const img = useMemo(() => {\n    const img = new Image(width, height)\n    img.src = imgSrc\n    return img\n  }, [width, height, imgSrc])\n\n  return (\n    <table ref={tableRef} className=\"game-grid\">\n      <tbody>\n        {Array(gridHeight).fill(0).map((_, y) => (\n          <tr key={y}>\n            {Array(gridWidth).fill(0).map((_, x) => {\n              const id = `${x},${y}`\n              return (\n                <td\n                  key={x}\n                  className=\"piece-positioner\"\n                  data-id={id} style={{\n                    width: pieceWidth,\n                    height: pieceHeight,\n                  }}\n                >\n                  <Piece\n                    id={id}\n                    pieceWidth={pieceWidth}\n                    pieceHeight={pieceHeight}\n                    width={width}\n                    height={height}\n                    left={x * pieceWidth * -1}\n                    top={y * pieceHeight * -1}\n                    img={img}\n                  />\n                </td>\n              )\n            })}\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  )\n\n}\n\n\nexport default function ConditionalGrid(props: GridProps) {\n  if (!props.width || !props.height) {\n    return null\n  }\n  return (\n    <Grid\n      {...props}\n    />\n  )\n}\n","import { useCallback, useRef, useState } from'react'\nimport GameLogic from './logic'\nimport { useElementSize } from './utils'\n\nimport Menu from './Menu'\nimport GameGrid from './Grid'\n\n\n\ntype GameProps = {\n  img: string\n}\n\n// The game state where the actual fun happens.\nexport default function Game({ img }: GameProps) {\n\n  const [showHelp, setShowHelp] = useState<boolean>(false)\n  const [isStarted, setStarted] = useState<boolean>(false)\n  const [showGrid, setShowGrid] = useState<boolean>(false)\n\n  const imgRef = useRef<HTMLImageElement>(null)\n  const stageRef = useRef<HTMLDivElement>(null)\n\n  const [imgWidth, imgHeight] = useElementSize(imgRef.current)\n  // const [stageWidth, stageHeight] = useElementSize(stageRef.current)\n\n  const onLoadImage = () => setTimeout (function () {\n    // .. then we tell the component to show the grid (this will trigger a re-render)\n    setShowGrid(true)\n  }, 2000)\n\n  // Sets up the game logic (duh). This is called after the game-grid component has fully rendered.\n  const setupGameLogic = useCallback(grid => {\n    if (stageRef.current && imgRef.current) {\n\n      // Create a new instance of GameLogic, passing it the components it\n      // requires (via their refs), ..\n      const logic = new GameLogic(grid, stageRef.current, imgRef.current)\n\n      // .. make it start, ..\n      logic.start()\n      setStarted(true)\n\n      // .. listen to when it finishes, ..\n      logic.onFinished(() => window.alert('You did it!! (reload the window to play again)'))\n\n    }\n  }, [])\n\n  return (\n    <>\n      <Menu toggleHelp={setShowHelp} />\n      <div className=\"game-wrapper\">\n        <div ref={stageRef} className=\"container stage\" />\n        <div className=\"grid-wrapper\">\n          <img\n            alt=\"Kitty\"\n            src={img}\n            className={`\n              base-img\n              ${isStarted ? 'transparent' : ''}\n              ${showHelp ? 'semi-transparent' : ''}\n            `}\n            ref={imgRef}\n            onLoad={onLoadImage}\n          />\n          {showGrid && (\n            <GameGrid\n              imgSrc={img}\n              width={imgWidth}\n              height={imgHeight}\n              pieceSizeRatio={2}\n              onLoad={setupGameLogic}\n            />\n          )}\n        </div>\n      </div>\n    </>\n  )\n\n}\n","import { useEffect, useState } from'react'\nimport ResizeObserver from 'resize-observer-polyfill'\n\n\n\ntype Size = [number, number]\n\nexport function useElementSize(element: HTMLElement | null): Size {\n  const [size, setSize] = useState<Size>([0, 0])\n  useEffect(() => {\n    if (element) {\n      const observer = new ResizeObserver((entries: Array<ResizeObserverEntry>) => {\n        const { contentRect } = entries[0]\n        setSize([\n          contentRect.width,\n          contentRect.height,\n        ])\n      })\n      observer.observe(element)\n      return () => observer.unobserve(element)\n    }\n  }, [element])\n  return size\n}\n","import { useState } from 'react'\n\nimport img from './images/kitty.jpg'\n\nimport StartScreen from './StartScreen'\nimport Game from './Game'\n\n\nexport default function App() {\n\n  const [isStarted, setStarted] = useState<boolean>(false)\n\n  if (isStarted) {\n    return (\n      <Game img={img} />\n    )\n  } else {\n    return (\n      <StartScreen onStart={() => setStarted(true)} />\n    )\n  }\n\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\n// import reportWebVitals from './reportWebVitals';\n\nimport { version } from '../package.json'\n\nimport App from './App'\n\nconsole.log(`Version: ${version}`)\nconsole.log(`Build: ${process.env.NODE_ENV}`)\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('app'),\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals(console.log.bind(null, 'web vitals:'));\n"],"sourceRoot":""}